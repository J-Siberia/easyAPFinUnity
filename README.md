<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
 tex2jax: {
 inlineMath: [['$', '$'] ],
 displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
 }
 });
</script>

# easyAPFinUnity
ロボットの経路計画法の一つである人工ポテンシャル法をUnityで簡単に実装したもの

# 概要
人工ポテンシャル法では以下の数式を用いて，ロボットが障害物を自動で回避しながら目的地まで移動する．
ここで，$c_{g}$，$c_{o}$，$l_{g}$，$g_{o}$は定数であり，
$||{}^{r}p_{g}||^{2}$および$||{}^{r}p_{oi}||^{2}$はそれぞれ目標位置からロボットまでの距離，障害物からロボットまでの距離である．

$
  {}^{r}U = \frac{1}{c_{g}} {}^{r}U_{o}  {}^{r}U_{g} + {}^{r}U_{g}
$

$
  {}^{r}U_{g} = c_{g}  \left(1-\exp \left( - \frac{||{}^{r}p_{g}||^{2}}{l^{2}_{g}} \right) \right)
$

$
  {}^{r}U_{o} = \sum_{i \in N_{0}} c_{o}\exp \left( - \frac{||{}^{r}p_{oi}||^{2}}{l^{2}_{o}} \right) 
$

一番目のポテンシャル場${}^{r}U$を求める関数を$f$とする．
この関数$f$の勾配を求めることによって，ロボットに与える力を計算できる．
その力による移動を続けると最終的に目標地点に到着する．

なお，このプログラムでは，前述の式で求めた合力をそのまま力としてロボットに加えるか，直接速度としてロボットに与えるのか，ということをシミュレーション中に選択できる(後者は目標地点まで辿り着けないことが多い)．

# オブジェクトについて
シミュレーションにおいて，緑色の球体がロボットであり，円柱と直方体を組み合わせた白色の物体が目標地点を示すオブジェクトである．
緑色の球体はこの白色のオブジェクトに向かって進んでいく．
この二つ以外のオブジェクトは全て障害物である．

# 実装について
目標地点の座標とロボットの現在位置は既知としている．

障害物の座標はロボットからRayを飛ばして求める．
具体的には，ロボットから飛ばしたRayが障害物の表面と交差した点を障害物の座標としている．

# シミュレーションについて
このプログラムには，シミュレーションの場面として3つのステージを用意している．

また，前述の式中に存在する定数はUIを通じてシミュレーション中に変更できる．